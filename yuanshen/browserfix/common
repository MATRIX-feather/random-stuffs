#!/bin/bash
set -e;

#脚本返回值定义
#shellcheck source=returncodes
source returncodes

#文件前缀，用来防止和其他软件或脚本冲突
readonly FILEPREFIX="ysbf" #YuanShenBrowserFix

#打开URL时使用的指令，具体调用是：$OPENCOMMAND <URL>
readonly OPENCOMMAND="xdg-open"

#目标用户名，用来防止多用户冲突
readonly TARGETUSERNAME="${USERNAME:-$(whoami)}"

#目标URL文件，browserfix会读取其中的信息
readonly TARGETFILE="/dev/shm/${FILEPREFIX}-url-${TARGETUSERNAME}"

#结束内容，当browserfix读取的内容和这里一致时将退出
readonly ENDCONTENT="die"

#记录目标，如果非空，则当log被调用时也会向目标位置输出一份一样的日志
#照理说在这里设置和在外面设置环境变量的效果是一样的，但我更建议设置环境变量
#readonly LOGTARGET=""

#应用名，用于区分各个脚本
#不建议改变
readonly APPNAME="$(basename "$(realpath "$0")")"

#脚本PID
#请勿改变
readonly PID="$$"

#脚本PID锁目标，可以用来确保一次只有一个实例
#不建议改变
readonly PIDLOCKTARGET="/dev/shm/${FILEPREFIX}-lock-${APPNAME}"

#处理SIGTERM
trap handle_term SIGTERM
trap handle_term SIGINT

#handle_term，可以被脚本override
function handle_term()
{
    log "再见！"
    exit 0
}

function log()
{
    local externalMsg="$*";
    local msg="[${APPNAME}] [$(date "+%Y-%m-%d %H:%M:%S")] ${externalMsg}"

    echo "${msg}"
    if [ -n "$LOGTARGET" ];then
        echo "${msg}" >> "$LOGTARGET" || true;
    fi;

    unset externalMsg
    unset msg
}

#让函数只读
readonly -f log

function die()
{
    local ret="$1"
    local reason="$2"
    local msg="${APPNAME}无法继续运行(${ret})，因为：${reason}"
    log "${msg}"
    exit "${ret}" || exit 255
}

readonly -f die

function createpid()
{
    if [ -f "${PIDLOCKTARGET}" ];then
        local content="$(cat "${PIDLOCKTARGET}")"

        #检查pid对应的进程是否存在
        if kill -s 0 "${content}" 2>/dev/null;then
            die $RET_PLCREATE_FAILED "[createpid] 已经有另一个${APPNAME}的实例了(PID:{$content})"
        else
            log "[createpid] 设置${PIDLOCKTARGET}的进程(PID:${content})不存在？"
            log "[createpid] 默认它是被干了，正在写入新值"
        fi;

        unset content
    fi;

    echo "${PID}" > "${PIDLOCKTARGET}"
}

readonly -f createpid

function removepid()
{
    if [ -f "${PIDLOCKTARGET}" ];then
        local content="$(cat "${PIDLOCKTARGET}")"

        if [ ! "${content}" == "$PID" ];then
            die $RET_PLREMOVE_PIDMISMATCH "[removepid] ${PIDLOCKTARGET}中的PID信息(${content})和当前PID(${PID})不同"
        fi;

        rm "${PIDLOCKTARGET}"

        unset content
    else
        log "[removepid] 未找到PID锁文件(${PIDLOCKTARGET})"
    fi
}

readonly -f removepid